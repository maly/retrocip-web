<!DOCTYPE html>
<html lang="cs-CZ">
  <!-- Beautiful Jekyll 5.0.0 | Copyright Dean Attali 2020 -->
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>Alpha: První program</title>

  

  <meta name="description" content="Nejjednodušší program bude obligátní „blikání LEDkou“. Po pravdě řečeno – zatím nemáme moc jiných způsobů, jak sepřesvědčit, že systém funguje, kromě zmíněného připojení rezistorů k datové sběrnici, simulace instrukce NOP a sledování změn na adresové sběrnici. Ale máme LED na výstupu SOD! Zapojte tedy obě paměti k procesoru a zkusíme...">

  

  

  <link rel="alternate" type="application/rss+xml" title="" href="http://localhost:4000/feed.xml">

  

  

  


  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  

  
  
  

  

  <meta property="og:title" content="Alpha: První program">
  <meta property="og:description" content="Nejjednodušší program bude obligátní „blikání LEDkou“. Po pravdě řečeno – zatím nemáme moc jiných způsobů, jak sepřesvědčit, že systém funguje, kromě zmíněného připojení rezistorů k datové sběrnici, simulace instrukce NOP a sledování změn na adresové sběrnici. Ale máme LED na výstupu SOD! Zapojte tedy obě paměti k procesoru a zkusíme...">

  
  <meta property="og:image" content="http://localhost:4000/wp-content/uploads/sites/6/favicon/retrocip.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="">
  <meta property="og:article:published_time" content="2018-05-10T09:31:52+02:00">
  <meta property="og:url" content="http://localhost:4000/alpha-prvni-program/">
  <link rel="canonical" href="http://localhost:4000/alpha-prvni-program/">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@retrocip">
  <meta name="twitter:creator" content="@retrocip">

  <meta property="twitter:title" content="Alpha: První program">
  <meta property="twitter:description" content="Nejjednodušší program bude obligátní „blikání LEDkou“. Po pravdě řečeno – zatím nemáme moc jiných způsobů, jak sepřesvědčit, že systém funguje, kromě zmíněného připojení rezistorů k datové sběrnici, simulace instrukce NOP a sledování změn na adresové sběrnici. Ale máme LED na výstupu SOD! Zapojte tedy obě paměti k procesoru a zkusíme...">

  
  <meta name="twitter:image" content="http://localhost:4000/wp-content/uploads/sites/6/favicon/retrocip.png">
  

  


  

  

</head>


  <body>
    
 <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="/aboutme">About Me</a>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Resources</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="https://beautifuljekyll.com">Beautiful Jekyll</a>
                  <a class="dropdown-item" href="https://www.markdowntutorial.com/">Learn markdown</a>
            </div>
          </li>
        
          <li class="nav-item">
            <a class="nav-link" href="https://deanattali.com">Author's home</a>
          </li></ul>
  </div>

  

  
    <div class="avatar-container">
      <div class="avatar-img-border">
        <a href="http://localhost:4000/">
          <img alt="Navigation bar avatar" class="avatar-img" src="/wp-content/uploads/sites/6/favicon/retrocip.png" />
        </a>
      </div>
    </div>
  

</nav>
 <!-- TODO this file has become a mess, refactor it -->
<!-- prettier-ignore -->

  



<header class="header-section ">
  
  <div class="intro-header no-img">
    <div class="container-md">
      <div class="row">
        <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
          <div class="post-heading">
            <h1>
              Alpha: První program
            </h1>
             
            <span class="post-meta"
              >Vydáno 10. 5. 2018</span
            >
              
          </div>
        </div>
      </div>
    </div>
  </div>
</header>




<div
  class=" container-md "
>
  <div class="row">
    <div
      class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 "
    >
       

      <article role="main" class="blog-post"><p>Nejjednodušší program bude obligátní „blikání LEDkou“. Po pravdě řečeno – zatím nemáme moc jiných způsobů, jak sepřesvědčit, že systém funguje, kromě zmíněného připojení rezistorů k datové sběrnici, simulace instrukce NOP a sledování změn na adresové sběrnici. Ale máme LED na výstupu SOD!</p>

<p>Zapojte tedy obě paměti k procesoru a zkusíme si naprogramovat první program. Bude to nějak takto:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inicializace()
while(true) {
  SOD = 1
  delay()
  SOD = 0
  delay()
}
</code></pre></div></div>

<p>A máme to, rachota skončila, můžeme pokračovat…</p>

<p>Vlastně ne, teď to teprve začne. Musíme tohle všechno naprogramovat v assembleru. Začneme inicializací.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> .org 0

; inicializace()

RESET: DI

  LXI SP, 0000h
</code></pre></div></div>

<p>Nejprve řekneme assembleru, že program bude začínat na adrese 0. Bývá dobrým zvykem si tento bod nějak pojmenovat – třeba návěštím RESET.</p>

<p>První instrukce je DI. Ta zakáže přerušení. Náš systém sice přerušení nepoužívá, ale patří k dobrému zvyku na začátku práce, než jsou nastavené všechny potřebné věci, zakázat přerušení. Kdyby nějaké přišlo dřív, než je nastavený například ukazatel zásobníku, systém by zhavaroval.</p>

<p>Další instrukce nastaví ukazatel zásobníku na konec paměti RAM. Ta u Alphy zabírá paměťový prostor 8000h – FFFFh. Takže nastavíme SP na hodnotu „o jedna vyšší než poslední volná adresa“ – tedy FFFFh+1 = 0000H. Instrukce LXI SP poslouží výborně.</p>

<p>Po této inicializaci máme procesor připravený na práci. Nemusíme inicializovat nic víc – ostatně v našem systému nic víc není. Můžeme tedy napsat tu smyčku:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOOP: 
  MVI A, 11000000b
  SIM
  CALL DELAY
  MVI A, 01000000b
  SIM
  CALL DELAY
  JMP LOOP
</code></pre></div></div>

<p>Nejprve nastavujeme SOD na 1. K tomu slouží instrukce SIM. Připomeňme si: tato instrukce vezme hodnotu v registru A a podle ní nastaví SOD a masku přerušení (ta nás teď nezajímá). Pro nastavení musí být druhý nejvyšší bit (D6) roven 1. Pokud tomu tak je, procesor pošle hodnotu nejvyššího bitu (D7) na výstup SOD.</p>

<p>Následuje volání čekací smyčky. Tu zatím neřešíme, ta bude „někde, nějak, později“. Prostě jen skočíme na adresu,kde bude čekací rutina, a ta se pomocí instrukce RET zase vrátí zpátky.</p>

<p>Následuje analogicky nastavení SOD na hodnotu 0, opět volání čekací rutiny, a po ní skok zase na začátek celého procesu.</p>

<p>Tím je jádro programu hotové. Jak na tu čekací smyčku?</p>

<p>K čekání se mohou použít různé způsoby. Například instrukce NOP – zabere 4 takty, což u našeho systému představuje zhruba 2,17 mikrosekund. Pokud jich použijeme tisíc, bude to 2,17 milisekund, pokud sto tisíc, bude to 217 milisekund, tedy skoro čtvrt sekundy. To by šlo použít.</p>

<p>Teda, šlo, kdybychom mohli do paměti uložit sto tisíc instrukcí. Nemůžeme. 32768 je maximum. Co s tím?</p>

<p>Opět použijeme smyčku. Prázdnou, uvnitř se nebude dít nic. Jen budeme odečítat od zadané hodnoty k nule, a až dojdeme k té nule, smyčka skončí. Nějak takto:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delay() {
  unsigned int d = KONSTANTA
  do {
    d--;
  } while (d!=0)
}
</code></pre></div></div>

<p>Použijeme dvojici registrů D, E. Do ní si uložíme časovací konstantu, a pak budeme jen ve smyčce snižovat hodnotu DE o 1 a kontrolovat, jestli je výsledek 0. Pokud ano, tak skončíme, pokud ne, točíme se znovu.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELAY:              
            LXI     D, KONSTANTA 
DLOOP:      DCX     D 
            MOV     A,D
            ORA     E
            JNZ     DLOOP
            RET
</code></pre></div></div>

<p>Smyčka DLOOP začíná snížením hodnoty v dvojici registrů D a E – DCX D. Teď musíme zkontrolovat, jestli je výsledek 0. Bohužel (šestnáctibitová) instrukce DCX nenastaví příznak zero (to dělají jen instrukce osmibitové). Použije se opěttrik, totiž logický součet (OR) hodnot v registrech D a E. Výsledek bude 0, pokud D i E budou nulové. A protože nemáme takto obecnou instrukci, musíme si nejprve hodnotu z jednoho registru zkopírovat do akumulátoru a pakudělat OR s druhým registrem. Instrukce ORA podle výsledku nastaví příznak Z a my tedy můžeme podle toho skákat – instrukcí JNZ, což je vlastně JUMP if NOT ZERO.</p>

<p>A teď otázka za sto bodů: Jak dlouho ta smyčka bude probíhat? Jasně, záleží to na té konstantě a bude to přímo úměrné. Ale kolik to bude? Dalo by se to spočítat?</p>

<p>Inu, dalo. Vezměte si k ruce <a href="http://ee.sharif.edu/~sakhtar3/articles/8080-8085/8085%20Instruction%20Set.pdf">tabulku s instrukcemi a jejich trváním</a> a napište si, kolik která instrukce zabere taktů:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELAY:              
            LXI     D, KONSTANTA ; 10 T
DLOOP:      DCX     D            ;  6 T
            MOV     A,D          ;  4 T
            ORA     E            ;  4 T
            JNZ     DLOOP        ; 10 T / 7 T - 10 pokud se skáče, 7 pokud se neskáče
            RET                  ; 10 T
</code></pre></div></div>

<p>Pokud bude konstanta = 1, proběhne tento cyklus přesně jednou. Zabere to tedy 10 + {6 + 4 + 4 + 7} + 10 = 41 T</p>

<p>Pokud bude konstanta = 2, proběhne tento cyklus takto:</p>

<p>10 + {6 + 4 + 4 + 10} + {6 + 4 + 4 + 7} + 10 = 65 T</p>

<p>Pokud bude konstanta = 3, poběží následujícím způsobem:</p>

<p>10 + {6 + 4 + 4 + 10} + {6 + 4 + 4 + 10} + {6 + 4 + 4 + 7} + 10 = 89 T</p>

<p>Je tedy vidět, že základní čekací doba je 41 T, a pokud zvýšíme konstantu o 1, zvýší to čekání o 24 T. Vzorec tedy je:</p>

<p>T = 41 + (N – 1) x 24</p>

<p>a z toho: N = (T – 41) / 24 + 1</p>

<p>Pokud bude konstanta rovna 100, bude čekání 41 + 99 x 24 = 2417 T.</p>

<p>Je to logické. První a poslední instrukce (LXI, RET) proběhnou vždy jen jednou (20T). Vnitřní smyčka jsou čtyři instrukce, a doba jejich provádění se liší podle toho, jestli už se dosáhlo nuly. Pokud ne, tak instrukce JNZ skáče a trvá 10T. Pokud ano, instrukce JNZ neskáče a trvá jen 7T. Průchod smyčkou tedy trvá 24T (6 + 4 + 4 + 10), pokud jde o poslední průchod, tak pouze 21T.</p>

<blockquote>
  <p>Vzorec můžeme samozřejmě zapsat jako T = 24 * N + 17</p>
</blockquote>

<p>Co se stane, když bude konstanta rovna 0? No, hned první DCX D odečte jedničku od 0000h, operace přeteče a výsledek bude FFFFh. Smyčka se tedy vykoná nikoli nula krát, ale 65536x!</p>

<p>Kolik vlastně taktů potřebujeme takto „propálit“, aby bylo zpoždění třeba půl sekundy? Víme, že procesor pracuje s taktem 1,8432 MHz, to znamená, že za sekundu vykoná 1 843 200 taktů. Na půlsekundové zpoždění tedy potřebujeme polovinu, ergo 921600 taktů. Zanedbáme takty, které zabere volání podprogramu instrukcí CALL, časování není zde úplně kritické.</p>

<p>Magická konstanta N bude tedy:</p>

<p>N = (921600 – 41) / 24 + 1 = 38399 (zaokrouhleně)</p>

<p>A co kdybychom chtěli blikat ještě pomaleji, třeba se sekundovými čekacími smyčkami? No, je to prosté, použijeme dvojnásobnou konstan… aha! Dvojnásobná hodnota je 76798, a to se nám do registrů nevejde. Tak zavoláme půlsekundové čekání dvakrát!</p>

<p>Anebooo – co když do smyčky mezi DCX D a MOV naházíme několik NOPů? Třeba pět:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELAY:              
            LXI     D, KONSTANTA ; 10 T
DLOOP:      DCX     D            ;  6 T
            NOP                  ;  4 T
            NOP                  ;  4 T
            NOP                  ;  4 T
            NOP                  ;  4 T
            NOP                  ;  4 T
            MOV     A,D          ;  4 T
            ORA     E            ;  4 T
            JNZ     DLOOP        ; 10 T / 7 T - 10, pokud se skáče, 7 pokud se neskáče
            RET                  ; 10 T
</code></pre></div></div>

<p>Pět NOPů, každý po 4T, to máme 20 T. O tuto hodnotu se zvýší čas nutný k průchodu smyčkou. Vzorec se tedy změní na:</p>

<p>T = 61 + (N – 1) x 44</p>

<p>Půlsekundové zpoždění s touto rutinou bude vyžadovat konstantu 20945, sekundové pak 41890. Platíme za to tím, že program zabere v paměti víc místa.</p>

<p>Všimli jste si drobné nevýhody celé rutiny? Pracuje s registry D, E a A. Co když ale v A jsou nějaké informace, které chceme zachovat?</p>

<p>Lze samozřejmě použít PUSH PSW a POP PSW, tedy uložit registr A a opět ho obnovit. A asi i rovnou uložit DE. Ale jsme v assembleru: neděláme nic, co není nutné!</p>

<p>Můžeme rozložit dekrement dvojice registrů D a E na dvě vnořené smyčky. V té vnitřní se bude dekrementovat hodnota v registru E, v té vnější hodnota v registru D. Díky tomu, že instrukce dekrementace osmibitového registru správně nastavuje příznaky, můžeme rovnou testovat, zda je výsledek operace 0:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELAY2:             
            LXI     D, KONSTANTA2 ; 10 T
DLOOP2:     DCR     E             ;  4 T
            JNZ     DLOOP2        ; 10 T / 7 T
            DCR     D             ;  4 T
            JNZ     DLOOP2        ; 10 T / 7 T
            RET                   ; 10 T
</code></pre></div></div>

<p>Vzorec se trošku zesložití – zachována zůstane konstanta 20 T na první a poslední instrukci. Nejvnitřnější smyčka zabere 14 T / 11 T (pro E nulové): 14 x (E – 1) + 11</p>

<p>Vnější smyčka zabere (počet taktů vnitřní smyčky) + 14 T / 11 T pro D = 0. Nesmíme ale zapomenout na to, že hodnota E se uvažuje pouze při prvním průběhu, při dalších už je E = 256 (ve skutečnosti 0, ale ta se chová jako 256).Pokud je E=256, zabere vnitřní smyčka 3581 T.</p>

<p>Tedy:</p>

<p>(14 x (E – 1) + 11) + 11 (to je první průběh smyčkou E + hodnota pro poslední průběh smyčkou D) plus</p>

<p>(D – 1) x (14 + 3581) (průběh plnou smyčkou E + vlastní smyčka D)</p>

<p>T = 20 + 14 x (E – 1) + 11 + 11 + (D – 1) x (14 + 3581) = 42 + 14 x (E – 1) + 3595 x (D – 1)</p>

<p>Zásadní rozdíl proti předchozí verzi je, že registry D a E jsou dekrementovány nezávisle, takže pokud nastavíte hodnotu DE = 0001h, bude se to ve skutečnosti chovat, jako by v registru D byla hodnota 256. Nejnižší možná hodnota, při níž proběhne rutina lineárně bez jakýchkoli skoků je tedy 0101h. Pak zabere rovných 42 T. Pokud bude hodnota 0000h, bude to jako D=256 a E=256, tedy provedení bude trvat 920337 T. Což je o něco méně než půl sekundy…</p>

<h2 id="překlad-a-spuštění">Překlad a spuštění</h2>

<p>Program máme napsaný, teď nastal čas ho přeložit. Spusťte si ASM80 (<a href="https://www.asm80.com">https://www.asm80.com</a>) a kliknutím na New file založte nový soubor. Do něj napište výše uvedené příkazy. Uložte jej pod názvem test.a80 – přípona .a80 je důležitá, podle ní překladač pozná, že jde o program pro procesor 8080/8085). Klikněte na Compile.</p>

<p>V seznamu souborů vlevo se objeví dva nové soubory: test.a80.lst a test.a80.hex. První je výpis programu včetně operačních kódů a umístění v paměti, takzvaný listing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000                          .ORG   0   
0000                          ; inicializace()
0000   F3           RESET:    DI   
0001   31 FF FF               LXI   SP,0000h   
0004                LOOP:     
0004   3E C0                  MVI   A,11000000b   
0006   30                     SIM   
0007   CD 13 00               CALL   DELAY   
000A   3E 40                  MVI   A,01000000b   
000C   30                     SIM   
000D   CD 13 00               CALL   DELAY   
0010   C3 04 00               JMP   LOOP   
0013                WAIT:     EQU   38399   
0013                DELAY:    
0013   11 FF 95               LXI   D,WAIT   
0016   1B           DLOOP:    DCX   D   
0017   7A                     MOV   A,D   
0018   B3                     ORA   E   
0019   C2 16 00               JNZ   DLOOP   
001C   C9                     RET
</code></pre></div></div>

<p>Druhý (HEX) je kód, určený k naprogramování paměti. Stáhněte si jej (pravý klik na název, Download) a použijte k nahrání do paměti EEPROM. Konkrétní postup se liší podle zvoleného programátoru.</p>

<p>Paměť zapojte zpátky do systému a zapněte napájení. Pokud jste neudělali při zapojení nikde chybu, měla by dioda po chvilce blikat s frekvencí 1 Hz. Úvodní prodleva je dána velikostí RC článku na vstupu RESET.</p>

<p>Funguje? Gratuluji, právě jste si postavili vlastníma rukama osmibitový počítač a naprogramovali ho!</p>

<blockquote>
  <p>Námět na cvičení: Tato úloha by šla přepsat tak, aby nevyžadovala paměť RAM. Konstrukci tak můžete oživit jen s třemi IO: procesor, adresový latch a paměť ROM. Stačí místo volání podprogramu (CALL) zkopírovat čekací rutinu na dané místo. Dvakrát.</p>
</blockquote>
</article>

      
      <div class="blog-tags">
        <span>Tagy:</span>
        
        <a href="/tags#8085">8085</a>
        
        <a href="/tags#ASM80">ASM80</a>
        
        <a href="/tags#Assembler">Assembler</a>
        
        <a href="/tags#OMEN Alpha">OMEN Alpha</a>
        
      </div>
         <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=Alpha%3A+Prvn%C3%AD+program&url=http%3A%2F%2Flocalhost%3A4000%2Falpha-prvni-program%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Falpha-prvni-program%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Falpha-prvni-program%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

</section>


 

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a
            class="page-link"
            href="/alpha-pamet/"
            data-toggle="tooltip"
            data-placement="top"
            title="Alpha: paměť"
            >&larr; Předchozí</a
          >
        </li>
         
        <li class="page-item next">
          <a
            class="page-link"
            href="/alpha-seriove-rozhrani/"
            data-toggle="tooltip"
            data-placement="top"
            title="Alpha: Sériové rozhraní"
            >Následující &rarr;</a
          >
        </li>
        
      </ul>
      
  
  
  

  




    </div>
  </div>
</div>
 <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="/feed.xml" title="RSS">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">RSS</span>
    </a>
  </li><li class="list-inline-item">
    <a href="mailto:retrocip@maly.cz" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://www.facebook.com/martin.maly" title="Facebook">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Facebook</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/maly" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://twitter.com/retrocip" title="Twitter">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Twitter</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
      2020

      
        &nbsp;&bull;&nbsp;
        <span class="author-site">
          <a href="http://localhost:4000/">Retročip.cz</a>
        </span>
      

      
      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>
 
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  








  </body>
</html>
