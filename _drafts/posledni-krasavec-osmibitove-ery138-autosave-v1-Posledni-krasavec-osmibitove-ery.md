---
id: 142
title: PoslednÃ­ krasavec osmibitovÃ© Ã©ry
date: 2014-11-23T14:10:23+01:00
author: Martin Maly
layout: revision
guid: http://retrocip.uelectronics.info/138-autosave-v1/
permalink: /138-autosave-v1/
---
Ã‰ra osmibitovÃ½ch mikroprocesorÅ¯ trvala, kdyÅ¾ ji budeme hodnotit velmi striktnÄ›, jen pÃ¡r let. PrvnÃ­ osmibit od Intelu pÅ™iÅ¡el na trh v roce 1972 (8008), prvnÃ­ Å¡estnÃ¡ctibit pÅ™edstavila stejnÃ¡ firma v roce 1978&#8230;

<!--more-->

SamozÅ™ejmÄ› to nebylo takhle ostÅ™e ohraniÄenÃ©. Neznamenalo to, Å¾e v roce 1978 vÅ¡ichni zahodili osmibity a vrhli se na 16 bitÅ¯, ani Å¾e pÅ™ed rokem 1978 neexistovaly Å¡estnÃ¡ctibity. Encyklopedie uvÃ¡dÄ›jÃ­ jako prvnÃ­ Å¡estnÃ¡ctibitovÃ½ mikroprocesor IPC-16A/500, zvanÃ½ PACE, kterÃ½ vyrÃ¡bÄ›la spoleÄnost National Semiconductor od roku 1974.

Motorola pÅ™edstavila svÅ¯j osmibit 6800 v roce 1974, Å¡estnÃ¡ctibitovÃ½ 68000 pÅ™iÅ¡el v roce 1979. ZaÄÃ­nala Ã©ra domÃ¡cÃ­ch osmibitÅ¯, Spectrum vzniklo aÅ¾ za tÅ™i roky, Sinclair QL (s 68008, coÅ¾ je 68000 s osmibitovou sbÄ›rnicÃ­) v roce 1984. IBM PC s procesorem 8088 byl pÅ™edstaven v roce 1981. Tolik tedy k dobovÃ©mu rÃ¡mci.

NejznÃ¡mÄ›jÅ¡Ã­ osmibitovÃ© poÄÃ­taÄe &#8222;osmibitovÃ© Ã©ry&#8220; tedy vznikly aÅ¾ v dobÄ›, kdy na trhu byly Å¡estnÃ¡ctibitovÃ© procesory &#8211; bohuÅ¾el mnohem draÅ¾Å¡Ã­. I architektura byla draÅ¾Å¡Ã­, vÃ½roba desek taky&#8230; pro masovÃ© nasazenÃ­ se tedy aÅ¾ do 90. let vyvÃ­jely osmibitovÃ© systÃ©my.

Zilog Z80 byl pÅ™edstaven v roce 1976. Velmi vyspÄ›lÃ½ a komplexnÃ­ mikroprocesor se stal zÃ¡kladem spousty populÃ¡rnÃ­ch poÄÃ­taÄÅ¯. Mezi ÄtenÃ¡Å™i nenÃ­ jistÄ› mnoho tÄ›ch, co by pochybovali o tom, Å¾e tahle pÅ™epracovanÃ¡ a silnÄ› vylepÅ¡enÃ¡ &#8222;osmdesÃ¡t osmdesÃ¡tka&#8220; patÅ™Ã­ do pomyslnÃ© sÃ­nÄ› slÃ¡vy.

Ale jak jsem uÅ¾ naznaÄil v [minulÃ©m ÄlÃ¡nku o klonech](http://retrocip.uelectronics.info/klony-a-procesory/ "Klony a procesory"): Z80 mi v 80. letech uÄarovala. Byl to prvnÃ­ procesor, se kterÃ½m jsem opravdu pracoval a byl jsem z nÄ›j nadÅ¡enÃ½ (Slavo Labsky aka Busysoft v jednom svÃ©m demu pro ZX Spectrum dokonce Z80 opÄ›voval jako &#8222;vlastnÄ› Å¡estnÃ¡ctibitovÃ½ procesor&#8220;).

KdyÅ¾ jsem si pak poÅ™Ã­dil Atari ST, musel jsem se nauÄit assembler procesoru 68000 a byl jsem uneÅ¡en. OrtogonÃ¡lnÃ­ instrukÄnÃ­ sada, spousta adresnÃ­ch mÃ³dÅ¯, prostÄ› parÃ¡da! Ale mÄ›l jsem zato, Å¾e to je moÅ¾nÃ© aÅ¾ u Å¡estnÃ¡ctibitÅ¯. Z mÃ©ho omylu mÄ› vyvedly dva procesory: 8086, kterÃ½ byl sice Å¡estnÃ¡ctibitovÃ½, ale ve srovnÃ¡nÃ­ s 68k to byla tragÃ©die, a pak 6809.

[<img loading="lazy" class="aligncenter size-medium wp-image-139" src="http://retrocip.uelectronics.info/wp-content/uploads/sites/6/2014/03/6809-650x328.jpg" alt="6809" width="650" height="328" srcset="https://retrocip.cz/wp-content/uploads/sites/6/2014/03/6809-650x328.jpg 650w, https://retrocip.cz/wp-content/uploads/sites/6/2014/03/6809-1024x518.jpg 1024w, https://retrocip.cz/wp-content/uploads/sites/6/2014/03/6809.jpg 1476w" sizes="(max-width: 650px) 100vw, 650px" />](http://retrocip.uelectronics.info/wp-content/uploads/sites/6/2014/03/6809.jpg)

## 6809

Motorola po 6800 samozÅ™ejmÄ› neusnula na vavÅ™Ã­nech a pÅ™ipravila nÄ›kolik variant tÃ©hoÅ¾ procesoru (s integrovanou pamÄ›tÃ­, s omezenÄ›jÅ¡Ã­ sadou atd.) ZÃ¡roveÅˆ se ale pÅ™ipravovala i na vÄ›ci pÅ™Ã­Å¡tÃ­, a tak vyvÃ­jela vhodnÃ©ho nÃ¡stupce. Bylo jasnÃ©, Å¾e musÃ­ vyvinout Å¡estnÃ¡ctibit, ale zÃ¡roveÅˆ nechtÄ›la opustit osmibitovÃ½ trh, protoÅ¾e pro osmibity bylo jeÅ¡tÄ› mnoho let uplatnÄ›nÃ­. Proto zaÄaly vznikat v laboratoÅ™Ã­ch Motoroly dva procesory narÃ¡z. JednÃ­m z nich byl 68000 &#8211; Å¡estnÃ¡ctibitovÃ½ procesor, kterÃ½ byl ale navrÅ¾en jako plnÄ› 32bitovÃ½ s 16bitovou sbÄ›rnicÃ­ (model 68008 dokonce s osmibitovou &#8211; v tÃ© dobÄ› znamenalo rozÅ¡Ã­Å™enÃ­ datovÃ© sbÄ›rnice na dvojnÃ¡sobek neÃºnosnÃ© zdraÅ¾enÃ­ celÃ©ho systÃ©mu). A druhÃ½m byl prÃ¡vÄ› 6809.

V Äasopise Byte vyÅ¡el svÃ©ho Äasu [ÄlÃ¡nek od dvou nÃ¡vrhÃ¡Å™Å¯ 6809](http://retro.co.za/6809/documents/Byte_6809_Articles.pdf), takÅ¾e dodneÅ¡ka vÃ­me, proÄ byl procesor navrÅ¾en prÃ¡vÄ› tak, jak byl navrÅ¾en. Dnes je to cennÃ½ historickÃ½ materiÃ¡l, kterÃ½ popisuje tehdejÅ¡Ã­ stav vÃ½voje a mikroelektroniky. PojÄme se podÃ­vat na &#8222;design decisions&#8220;, kterÃ© nÃ¡vrhÃ¡Å™i udÄ›lali.

V prvnÃ­ Å™adÄ› bylo jasnÃ©, Å¾e nelze zahodit kompatibilitu s existujÃ­cÃ­m software pro 6800. Nakonec padlo rozhodnutÃ­ obÄ›tovat binÃ¡rnÃ­ kompatibilitu (tu mÃ¡ tÅ™eba Z80 s 8080), ale zachovat kompatibilitu na Ãºrovni zdrojovÃ©ho kÃ³du. Tedy tak, aby programy v assembleru 6800 Å¡ly pÅ™eloÅ¾it pro novÃ½ procesor ve funkÄnÄ› ekvivalentnÃ­ podobÄ›. Instrukce se tedy jmenovaly stejnÄ›, i kdyÅ¾ se pÅ™eklÃ¡daly na jinÃ© operaÄnÃ­ kÃ³dy.

ZadruhÃ© pro snÃ­Å¾enÃ­ nÃ¡kladÅ¯ bylo rozhodnuto, Å¾e nÃ¡vrhÃ¡Å™i pouÅ¾ijÃ­ ÄÃ¡sti, kterÃ© se osvÄ›dÄily v 6800 &#8211; napÅ™Ã­klad kombinaÄnÃ­ logika pro dekÃ³dovÃ¡nÃ­ instrukcÃ­ (6809 nepouÅ¾Ã­val mikrokÃ³d).

VÃ½vojÃ¡Å™i takÃ© podrobili existujÃ­cÃ­ zdrojovÃ© kÃ³dy pro procesor 6800 statickÃ© i dynamickÃ© analÃ½ze, aby zjistili, co vlastnÄ› programÃ¡toÅ™i pouÅ¾Ã­vajÃ­ a jak. Pro zajÃ­mavost &#8211; statickÃ¡ analÃ½za, kterÃ¡ nezohledÅˆuje napÅ™. prÅ¯bÄ›hy smyÄkou a pouze poÄÃ­tÃ¡ vÃ½skyty instrukcÃ­, ukÃ¡zala, Å¾e instrukcÃ­ LOAD (tedy pÅ™esuny z pamÄ›ti do registrÅ¯) je v kÃ³dech 23,4 %, STORE (opaÄnÃ½m smÄ›rem) 15,3 %, volÃ¡nÃ­ podprogramÅ¯ a nÃ¡vratÅ¯ je 13 procent, 11 procent tvoÅ™Ã­ podmÃ­nÄ›nÃ© skoky atd., aÅ¾ ke tÅ™em procentÅ¯m instrukcÃ­ sÄÃ­tÃ¡nÃ­ a odÄÃ­tÃ¡nÃ­. Bylo tedy zÅ™ejmÃ©, co je tÅ™eba posÃ­lit, jakÃ© instrukce jsou Äasto pouÅ¾Ã­vanÃ© (a majÃ­ tedy zÅ¯staty jednobajtovÃ©) a jakÃ© je moÅ¾nÃ© pÅ™esunout mezi instrukce s prefixem&#8230;

DalÅ¡Ã­ analÃ½za se zamÄ›Å™ila na instrukce, kterÃ© adresujÃ­ pomocÃ­ indexu. NejÄastÄ›ji (53 % pÅ™Ã­padÅ¯) byl index v rozmezÃ­ 1 &#8211; 31, ve 40 % pÅ™Ã­padÅ¯ byl index roven nule, 6 % Â pÅ™Ã­padÅ¯ pÅ™ipadalo na index v rozmezÃ­ 64 &#8211; 255, no a poslednÃ­ procento tvoÅ™ily indexy v rozsahu 32 &#8211; 63. Tohle zjiÅ¡tÄ›nÃ­ vedlo napÅ™Ã­klad k vÃ½raznÃ©mu rozÅ¡Ã­Å™enÃ­ adresnÃ­ch mÃ³dÅ¯.

Vzhledem k tomu, jak ÄastÃ© byly instrukce INC a DEC ve spojenÃ­ s adresovÃ¡nÃ­m, padlo rozhodnutÃ­ pÅ™idat adresnÃ­ mÃ³d, kterÃ½ dokÃ¡Å¾e automaticky zvyÅ¡ovat a sniÅ¾ovat hodnotu v indexovÃ©m registru.

No a v neposlednÃ­ Å™adÄ› se rozrostl poÄet registrÅ¯: K Å¡estnÃ¡ctibitovÃ©mu indexovÃ©mu registru X pÅ™ibyl registr Y, k ukazateli zÃ¡sobnÃ­ku S pÅ™ibyl ukazatel uÅ¾ivatelskÃ©ho zÃ¡sobnÃ­ku U, nÃ¡vrhÃ¡Å™i pÅ™idali osmibitovÃ½ registr DP (direct page) a spojili registry A a B do Å¡estnÃ¡ctibitovÃ©ho registru D.

Registr DP souvisÃ­ s adresovÃ¡nÃ­m. Procesory Motorola (i odvozenÃ½ MOS 6502) mÄ›ly totiÅ¾ moÅ¾nost odkazovat buÄ plnou adresou (2 bajty), nebo zkrÃ¡cenou, kdy adresu tvoÅ™il jen jeden bajt, ten niÅ¾Å¡Ã­, a vyÅ¡Å¡Ã­ byl vÅ¾dy 0. Tomuto pÅ™Ã­stupu se Å™Ã­kalo &#8222;zero page&#8220;, protoÅ¾e adresoval pouze buÅˆky v rozsahu 0000h &#8211; 00ffh. TakovÃ© adresovÃ¡nÃ­ bylo sice vÃ½hodnÃ©, ale na druhou stranu bylo v rozsahu nultÃ© strÃ¡nky brzo pÅ™eplnÄ›no. U procesoru 6809 existuje taky zkrÃ¡cenÃ© adresovÃ¡nÃ­, ale vyÅ¡Å¡Ã­ bajt nenÃ­ automaticky 0, ale je roven prÃ¡vÄ› obsahu registru DP. ProgramÃ¡tor tedy mÅ¯Å¾e &#8222;nultou strÃ¡nku&#8220; posunout kamkoli v pamÄ›ti (resp. nastavit vyÅ¡Å¡Ã­ bajt adresy).

### AdresnÃ­ mÃ³dy a indexy

AdresnÃ­ mÃ³dy zÅ¯staly tytÃ©Å¾, jakÃ© [znÃ¡me z procesoru 6800](http://strojak.cz/procesory-a-procesory/). VÃ½raznÄ› byly rozÅ¡Ã­Å™eny moÅ¾nosti indexace. Instrukce, kterÃ© pouÅ¾Ã­vajÃ­ indexovanou adresaci, obsahujÃ­ (minimÃ¡lnÄ›) o jeden bajt navÃ­c. V tomto bajtu, zvanÃ©m &#8222;post byte&#8220;, je uloÅ¾ena informace o tom, jak se indexuje a s jakÃ½mi registry.

ObecnÄ› lze pro indexovÃ¡nÃ­ pouÅ¾Ã­t indexovÃ© registry X a Y, ukazatele zÃ¡sobnÃ­ku S a U, a s urÄitÃ½mi omezenÃ­mi i ukazatel PC. Co mÃ¡me tedy na vÃ½bÄ›r?

  * IndexovÃ½ registr (X, Y, S, U) + konstantnÃ­ offset. Zde se rozliÅ¡uje nÄ›kolik moÅ¾nostÃ­ podle toho, jak velkÃ½ je offset. Pokud je 0, je to oznaÄeno v post byte a nenÃ­ zapotÅ™ebÃ­ dalÅ¡Ã­ pameÅ¥ovÃ¡ buÅˆka. DruhÃ¡ moÅ¾nost je, Å¾e offset je v rozmezÃ­ -16 aÅ¾ +15. V takovÃ©m pÅ™Ã­padÄ› je offset zapsÃ¡n rovnÄ›Å¾ v post byte. ZbÃ½vajÃ­cÃ­ dvÄ› moÅ¾nosti jsou &#8222;osmibitovÃ½ index&#8220; a &#8222;Å¡estnÃ¡ctibitovÃ½ index&#8220;.
  * K indexovÃ©mu registru (X, Y, S, U) je pÅ™iÄtena hodnota registru A, B nebo D (D je Å¡estnÃ¡ctibitovÃ© spojenÃ­ A a B).
  * Adresa je vzata pÅ™Ã­mo z indexovÃ©ho registru (X, Y, S, U) a potÃ© je jeho hodnota zvÃ½Å¡ena o 1 nebo 2. (Postinkrement)
  * Hodnota v indexovÃ©m registru (X, Y, S, U) je snÃ­Å¾ena o 1 nebo 2 a pak je vzata k adresaci. (Predekrement)
  * Adresa je dÃ¡na programovÃ½m ÄÃ­taÄem PC, k nÄ›muÅ¾ je pÅ™iÄten osmibitovÃ½ nebo Å¡estnÃ¡ctibitovÃ½ offset.

SluÅ¡nÃ¡ sestava, Å¾e? A vynÃ¡sobte si ji dvÄ›ma, protoÅ¾e vÅ¡echny tyhle adresnÃ­ mÃ³dy (aÅ¾ na dvÄ› vÃ½jimky) lze pouÅ¾Ã­t jako nepÅ™Ã­mÃ© (indirect), tj. adresa, kterou zÃ­skÃ¡me indexacÃ­, jeÅ¡tÄ› nenÃ­ ta cÃ­lovÃ¡, ale ukazuje do pamÄ›ti, ze kterÃ© se pÅ™eÄtou dva bajty, a teprve ty udÃ¡vajÃ­ efektivnÃ­ adresu, se kterou se bude pracovat.

PÅ™edstavme si, Å¾e od adresy 0800h mÃ¡me uloÅ¾enÃ© adresy nÄ›jakÃ½ch dat ke zpracovÃ¡nÃ­ a chceme je vÅ¡echny projÃ­t. NenÃ­ tÅ™eba Å¾Ã¡dnÃ½ch ÄachrÅ¯ s mnoha registry, staÄÃ­ tÅ™eba do X uloÅ¾it adresu tÃ© tabulky adres (0800h) a pak naÄÃ­tat data pÅ™Ã­mo z cÃ­lovÃ½ch lokacÃ­ pomocÃ­ LDA \[X++\] (hranatÃ© zÃ¡vorky znaÄÃ­ nepÅ™Ã­mou adresaci, X++ je postinkrement o 2.)

ZmÃ­nÄ›nÃ© vÃ½jimky u nepÅ™Ã­mÃ© adresace jsou prÃ¡vÄ› postinkrement / predekrement o 1. Pokud pouÅ¾Ã­vÃ¡te nepÅ™Ã­mou adresaci, nelze ji zkombinovat s posunem o 1, vÅ¾dy o 2!

### Relokace

VÃ½raznÃ© designÃ©rskÃ© rozhodnutÃ­ bylo posÃ­lenÃ­ podpory relokace. Pokud jste pracovali s osmibitovÃ½mi procesory a la 8080, byla adresa, na jakou mÃ¡ bÃ½t program nahrÃ¡n, zadÃ¡na pÅ™i pÅ™ekladu. Pokud se pak kÃ³d ocitl na jinÃ½ch adresÃ¡ch, vedly skoky nazdaÅ™bÅ¯h a havÃ¡rie nastala v Å™Ã¡du milisekund. Z80 nabÃ­dl relativnÃ­ skok, ale ten nenÃ­ vÅ¡espÃ¡snÃ½: jen 128 bajtÅ¯ dozadu a dopÅ™edu, navÃ­c volÃ¡nÃ­ podprogramu je opÄ›t s absolutnÃ­ adresou. Pokud si pamatujete na programy MONS3 a GENS3, ty bylo moÅ¾nÃ© nahrÃ¡t kamkoli do pamÄ›ti a odtamtud spouÅ¡tÄ›t &#8211; ve skuteÄnosti byla na zaÄÃ¡tku rutina, kterÃ¡ vÅ¡echny absolutnÃ­ adresy v kÃ³du vlastnÃ­ho programu zmÄ›nila.

NÃ¡vrhÃ¡Å™i 6809 posÃ­lili &#8222;relokovatelnost&#8220; programÅ¯ vÃ½znamnou mÄ›rou: vÅ¡echny relativnÃ­ skoky mohou mÃ­t osmibitovÃ½ i Å¡estnÃ¡ctibitovÃ½ offset, vÄetnÄ› instrukce volÃ¡nÃ­ podprogramu (JSR). Mohou vyuÅ¾Ã­vat i indexovanÃ© adresace, jak jsem psal vÃ½Å¡e.

### Dva zÃ¡sobnÃ­ky

MoÅ¾nÃ¡ vÃ¡s napadne FORTH, pro kterÃ½ je tento koncept jako stvoÅ™enÃ½. Ve skuteÄnosti nÃ¡vrhÃ¡Å™i mÄ›li na mysli jinou situaci: pÅ™edstavte si, Å¾e podprogram potÅ™ebuje vrÃ¡tit vÃ­c hodnot. Pokud je uloÅ¾Ã­ nÄ›kam do pamÄ›ti na pevnÄ› danou adresu, nebude reentrantnÃ­. Pokud je pÅ™edÃ¡ na zÃ¡sobnÃ­ku, je potÅ™eba nejprve vytÃ¡hnout nÃ¡vratovou adresu, tu si nÄ›kam uloÅ¾it (kam ale?), uloÅ¾it data a pak vrÃ¡tit nÃ¡vratovou adresu. PrÃ¡vÄ› tenhle problÃ©m vÃ½vojÃ¡Å™i obeÅ¡li druhÃ½m zÃ¡sobnÃ­kem U. Podprogram prostÄ› PUSHuje data, kterÃ¡ chce pÅ™edat, do druhÃ©ho zÃ¡sobnÃ­ku.

InstrukÄnÃ­ sada 6809 obsahuje dvÄ› instrukce PUSH &#8211; PSHS a PSHU. prvnÃ­ uklÃ¡dÃ¡ na standardnÃ­ zÃ¡sobnÃ­k, druhÃ¡ na uÅ¾ivatelskÃ½. Ale co uklÃ¡dÃ¡? SamozÅ™ejmÄ› obsah registrÅ¯. Zde nÃ¡vrhÃ¡Å™i pouÅ¾ili dalÅ¡Ã­ trik: za operaÄnÃ­m kÃ³dem PSHx je dalÅ¡Ã­ bajt, kterÃ½ Å™Ã­kÃ¡, kterÃ© registry se majÃ­ na zÃ¡sobnÃ­k uloÅ¾it. Jednou instrukcÃ­ tak mÅ¯Å¾eme uloÅ¾it kompletnÃ­ sadu registrÅ¯. CoÅ¾ je pomÄ›rnÄ› elegantnÃ­ Å™eÅ¡enÃ­, protoÅ¾e se instrukce pro uklÃ¡dÃ¡nÃ­ obsahu registrÅ¯ vÄ›tÅ¡inou vyskytujÃ­ v sÃ©riÃ­ch, navÃ­c nemuseli pro kaÅ¾dou kombinaci registrÅ¯ a zÃ¡sobnÃ­kÅ¯ dÄ›lat vlastnÃ­ operaÄnÃ­ kÃ³d.

### VÃ½tky

Ve vÃ½Å¡e zmÃ­nÄ›nÃ©m ÄlÃ¡nku z Byte jsou sepsÃ¡ny i vÃ½hrady ÄtenÃ¡Å™Å¯ a uÅ¾ivatelÅ¯, na kterÃ© konstruktÃ©Å™i odpovÃ­dajÃ­. NapÅ™Ã­klad: ProÄ nejsou blokovÃ© operace? Nejsou. NÄ›co bylo tÅ™eba obÄ›tovat, navÃ­c podle vÃ½vojÃ¡Å™Å¯ je programovÃ© Å™eÅ¡enÃ­ blokovÃ½ch operacÃ­ dÃ­ky mocnÃ½m moÅ¾nostem indexace pomÄ›rnÄ› jednoduchÃ©.

Nebo: ProÄ nejsou bitovÃ© operace? OdpovÄ›Ä: prodraÅ¾ilo by to celÃ½ procesor, tak jsme je, vzhledem k tomu, Å¾e nejsou Äasto pouÅ¾Ã­vanÃ©, oÅ¾eleli. ProÄ je nÃ¡sobenÃ­, ale nenÃ­ dÄ›lenÃ­? ProtoÅ¾e nÃ¡sobenÃ­ je mnohem ÄastÄ›jÅ¡Ã­ (tÅ™eba pÅ™i pÅ™Ã­stupu k dvojrozmÄ›rnÃ½m polÃ­m).

> PotÄ›Å¡ila mÄ› devÃ¡tÃ¡ vÃ½tka: &#8222;_ProÄ jste pÅ™idali vÅ¡echny ty adresnÃ­ mÃ³dy? JÃ¡ je nikdy nepouÅ¾iju!_&#8220; Jako bych si Äetl diskuse na Root.cz&#8230;

Na otÃ¡zku &#8222;proÄ nemÃ¡ registr DP vlastnÃ­ instrukce LOAD a STORE?&#8220; odpovÄ›dÄ›li tvÅ¯rci logicky: jeho obsah je natolik dÅ¯leÅ¾itÃ½, Å¾e by si programÃ¡tor mÄ›l bÃ½t vÄ›dom toho, Å¾e mÄ›nÃ­ nÄ›co podstatnÃ©ho, tak to nenÃ­ ÃºplnÄ› pÅ™Ã­moÄarÃ©.

### &#8230; a spousta drobnostÃ­ navrch

Procesor 6809 mÃ¡ tÅ™eba dvojici instrukcÃ­ TFR / EXG. TFR (transfer) pÅ™esouvÃ¡ obsah z jednoho registru do druhÃ©ho, EXG vzÃ¡jemnÄ› vymÄ›nÃ­ obsah dvou registrÅ¯. PlatÃ­ to jak pro osmibitovÃ© (A, B, DP a CC &#8211; pÅ™Ã­znakovÃ½ registr), tak pro Å¡estnÃ¡ctibitovÃ© (X, Y, S, U, SP a D).

PÅ™eruÅ¡enÃ­ (hardwarovÃ© &#8211; IRQ i softwarovÃ© &#8211; instrukce SWI, SWI2 a SWI3) uloÅ¾Ã­ automaticky na zÃ¡sobnÃ­k vÅ¡echny registry. Instrukce nÃ¡vratu z pÅ™eruÅ¡enÃ­ pak zase vÅ¡echny obnovÃ­. Procesor mÃ¡ ale i vstup FIRQ (Fast IRQ), kterÃ½ vyvolÃ¡ pÅ™eruÅ¡enÃ­, ale registry neuklÃ¡dÃ¡.

PodmÃ­nÄ›nÃ© skoky testujÃ­ nejen ÄtyÅ™i zÃ¡kladnÃ­ pÅ™Ã­znakovÃ© bity, ale i jejich moÅ¾nÃ© kombinace, takÅ¾e mÅ¯Å¾ete napÅ™. vyvolat skok, pokud je hodnota 1 vÄ›tÅ¡Ã­ nebo rovna hodnotÄ› 2 v bezznamÃ©nkovÃ© aritmetice (BHS &#8211; Higher or Same), ale mÅ¯Å¾ete kontrolovat totÃ©Å¾ pro ÄÃ­sla se znamÃ©nkem (BGE &#8211; Greater or Equal).

VÄ›tÅ¡ina instrukcÃ­ je velmi rychlÃ¡, zabÃ­rÃ¡ jen pÃ¡r taktÅ¯. Na rozdÃ­l od procesorÅ¯ z rodiny 8080/Z80, kterÃ© tÅ™eba pro naÄtenÃ­ operaÄnÃ­ho kÃ³du a jeho dekÃ³dovÃ¡nÃ­ zaberou ÄtyÅ™i takty, u 6809 je vÅ¡e mnohem rychlejÅ¡Ã­: NOP dva takty, podmÃ­nÄ›nÃ½ relativnÃ­ skok 3 takty, aritmetickÃ© Äi logickÃ© operace 6 taktÅ¯, nÃ¡sobenÃ­ 11 taktÅ¯ (6809 totiÅ¾ obsahuje hardwarovou nÃ¡sobiÄku 8&#215;8 bitÅ¯). SamozÅ™ejmÄ› pokud je potÅ™eba pracovat s indexovanÃ½m adresnÃ­m mÃ³dem a naÄÃ­tat post byte, prefix Äi offset, musÃ­te si patÅ™iÄnÃ½ poÄet taktÅ¯ pÅ™iÄÃ­st&#8230;

[DalÅ¡Ã­ podrobnosti o instrukÄnÃ­ sadÄ›.](http://koti.mbnet.fi/~atjs/mc6809/Information/6809Instructions.txt)

### Kam s nÃ­m?

6809 pÅ™iÅ¡el na trh na konci 70. let, ÄtyÅ™i roky po Z80. Mohly tyhle ÄtyÅ™i roky znamenat, Å¾e 6809 uÅ¾ nijak vÃ½raznÄ› do osmibitovÃ© Ã©ry nepromluvil? Dost moÅ¾nÃ¡ ano. I kdyÅ¾ vÅ¡echna ta Spectra a Atari pÅ™iÅ¡la aÅ¾ zaÄÃ¡tkem 80. let, mÄ›l 6809 smÅ¯lu. PravdÄ›podobnÃ½m dÅ¯vodem byla cena, a pak dalÅ¡Ã­ nÃ¡klady na pÅ™epsÃ¡nÃ­ software nebo uÄenÃ­ novÃ© instrukÄnÃ­ sady.

A tak vlastnÄ› jedinÃ½ &#8222;znÃ¡mÄ›jÅ¡Ã­&#8220; poÄÃ­taÄ, kterÃ½ pouÅ¾Ã­val 6809, byl TRS-80 CoCo, neboli &#8222;Tandy/RadioShack Color Computer&#8220;, kterÃ½ pÅ™iÅ¡el na trh v roce 1980. (ÄŒÃ­slice 80 v oznaÄenÃ­ TRS-80 odkazuje na pÅ™edchozÃ­ model tohoto poÄÃ­taÄe, kterÃ½ pouÅ¾Ã­val Z80.) PostupnÄ› vznikly tÅ™i verze, v BritÃ¡nii se vyrÃ¡bÄ›ly klony tohoto poÄÃ­taÄe pod oznaÄenÃ­m Dragon 32 / Dragon 64. Z dalÅ¡Ã­ch osmibitÅ¯ pouÅ¾Ã­valy 6809 francouzskÃ© poÄÃ­taÄe Thomson MO5 / TO7 / TO8, japonskÃ© FM7 a FM8 od Fujitsu, nebo poÄÃ­taÄ [Aamber Pegasus](http://www.neoncluster.com/aamber_pegasus/aamber_pegasus.html) (1981), kterÃ½ svÃ½m minimalistickÃ½m nÃ¡vrhem pÅ™ipomÃ­nal trochu ZX80/ZX81. _VÅ¡imnÄ›te si, Å¾e poÄÃ­taÄe s 6809 byly na trhu dÅ™Ã­v neÅ¾ tÅ™eba Sinclairovy geniÃ¡lnÃ­ stroje se Z80. Na chvÃ­li se zasnÃ­m a pÅ™edstavÃ­m si, jak by vypadalo Spectrum s 6809&#8230; MoÅ¾nÃ¡ si na to napÃ­Å¡u emulÃ¡tor. ğŸ˜‰_

Pro 6809 vznikl i zajÃ­mavÃ½ software. KromÄ› FORTHu nebo operaÄnÃ­ho systÃ©mu OS-9 (pozdÄ›ji upraven jako [NitrOS-9](http://sourceforge.net/apps/mediawiki/nitros9/index.php?title=Main_Page)) to byl tÅ™eba i Microsoft BASIC &#8211; ten jeÅ¡tÄ› v dobÄ›, kdy Bill Gates psal sÃ¡m programy. Â Gates pozdÄ›ji v [rozhovoru](http://americanhistory.si.edu/comphist/gates.htm) oznaÄil 6809 za nejlepÅ¡Ã­ osmibitovÃ½ procesor vÅ¯bec.

A jÃ¡ v tomhle s Billem souhlasÃ­m.

Å koda jen, Å¾e pÅ™iÅ¡el (asi) pozdÄ›. Sice bylo moÅ¾nÃ© pomocÃ­ transpileru pÅ™eloÅ¾it zdrojovÃ© programy 6809 pro mikroprocesor 68000, ale to uÅ¾ byla spÃ­Å¡ jen labutÃ­ pÃ­seÅˆ, stejnÄ› jako procesor Hitachi HD6309, [o kterÃ©m jsem se zmiÅˆoval minule](http://retrocip.uelectronics.info/klony-a-procesory/ "Klony a procesory"). OstatnÄ› 6309 si zaslouÅ¾Ã­ jeÅ¡tÄ› samostatnÃ½ dÃ­l, protoÅ¾e jeho historie je taky zajÃ­mavÃ¡. PÅ™Ã­Å¡tÄ›&#8230;

_PoznÃ¡mka: PÅ™i pÃ¡trÃ¡nÃ­ v archivech mÄ› zarazilo, jak obtÃ­Å¾nÃ© je najÃ­t dnes informace o tom, kdy byl kterÃ½ procesor uveden na trh. V datasheetech tyto informace nejsou, a krom vyloÅ¾enÃ½ch procesorovÃ½ch legend, u nichÅ¾ jsou data notoricky znÃ¡mÃ¡, jsou informace zmatenÃ© a neÃºplnÃ©, u spousty z nich to je napÅ™Ã­klad &#8222;v 70. letech&#8220;, u procesoru HD6309 jsem rok uvedenÃ­ na trh napÅ™Ã­klad nedohledal vÅ¯bec._